# -*- coding: utf-8 -*-
"""Подборка приемов в Python часть 3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WazRdDsaMdlxiinUjACdclRQwk4jgsan

В настоящем цикле статей будут разобраны приемы промышленного использования функциональности Python в коде

Далее представлена третья часть из цикла

# 1. Списковые включения, охватывающие несколько строк

**Обычные списковые включения** в Python — это компактный способ создания списков через синтаксис
* `ls = [выражение for переменная in итерируемый_объект]`.

Пример:
"""

ls = [i**2 for i in range(5)]
ls

"""**Как это работает:**  
1. **Итерируемый объект** (`range(5)`) генерирует значения от 0 до 4.  
2. **Переменная** (`i`) принимает каждое значение на каждой итерации.  
3. **Выражение** (`i**2`) вычисляется для каждого значения и добавляется в список.

В коде, используемом в производственной среде, чаще используют списковые включения, которые охватывают несколько строк и позволяют создавать списки с использованием многострочного синтаксиса для улучшения читаемости. Это особенно полезно при работе с сложными условиями или несколькими циклами.

Также обычно не используется стандартное имя переменной i — коректнее всего использовать более описательное имя.

Давайте перепишем приведённый выше код:
"""

squared_numbers = [
    number ** 2
    for number in range(5)
]

squared_numbers

"""Рассмотрим и другие примеры многострочных списковых включений из реальной практики

1. **Сложные условия**  
"""

# Фильтрация заказов с условием:
# - Только успешные статусы ("completed")
# - Сумма заказа > 1000 руб.
# - Дата выполнения в 2024 году
# - Исключение заказов с возвратами

filtered_orders = [
    order
    for order in orders
    if order["status"] == "completed"  # Успешный статус
    if order["amount"] > 1000          # Сумма > 1000 руб.
    if order["date"].startswith("2024")  # Год 2024
    if not order["returns"]            # Без возвратов
]

"""2. **Несколько циклов**  """

# Формирование списка возможных комбинаций доставки:
# - Города: Москва, Санкт-Петербург, Казань
# - Сроки: 1-3 дня
# - Условия: только для городов с доступными сроками

cities = {
    "Москва": [1, 2, 3],
    "Санкт-Петербург": [2, 3],
    "Казань": [1, 3]
}

delivery_options = [
    {
        "city": city,
        "days": days,
        "status": "Доступно"
    }
    for city, available_days in cities.items()
    for days in available_days
    if days >= 2  # Фильтр: сроки от 2 дней
    if city != "Казань" or days == 3  # Исключение Казани для дней !=3
]

print(delivery_options)

"""3. **Вложенные условия**"""

# Фильтрация сотрудников с условием:
# - Возраст > 30 лет
# - Опыт работы > 5 лет
# - Зарплата > 100000 руб.
# - Дополнительные условия:
#   - Для менеджеров: зарплата > 150000 руб.
#   - Для разработчиков: опыт > 7 лет

filtered_employees = [
    employee
    for employee in employees
    if employee["age"] > 30  # Основное условие: возраст > 30
    if employee["experience"] > 5  # Основное условие: опыт > 5 лет
    if employee["salary"] > 100000  # Основное условие: зарплата > 100000
    if (
        (employee["position"] == "менеджер" and employee["salary"] > 150000)
        or
        (employee["position"] == "разработчик" and employee["experience"] > 7)
    )  # Вложенное условие для позиций
]

"""### Особенности синтаксиса  
- **Многострочные конструкции** поддерживаются Python, но требуют **отступов** для всех элементов включения.  
- **Условия** (`if`) и **циклы** (`for`) можно комбинировать в любом порядке.  
- **Генераторы списков** (аналогичны включениям, но возвращают итератор) также поддерживают многострочный формат.

# 2. Индексирование вложенных словарей

Индексирование вложенных словарей — это преобразование списков внутри словарей в структуры с явными индексами.

Обычный способ индексирования вложенных словарей:
"""

my_dictionary = {
    "data": {
        "num": 1
    }
}

my_dictionary["data"]["num"]

"""Здесь есть несколько проблем:

1. Словари в коде, готовом к производственной среде, имеют гораздо больше уровней вложенности.
2. Имена ключей словарей намного длиннее.
3. Мы обычно не можем уместить весь код вложенного индексирования в одну строку.

Поэтому мы разбиваем его на несколько строк, примерно так:
"""

result = (
    my_dictionary
    ["data"]
    ["num"]
)

result

"""**Пример из реальной практики:**"""

# Исходные данные: профили клиентов
customer_data = {
    "data": {
        "num": {
            "total_users": 1000,
            "active_users": 750,
            "inactive_users": 250
        }
    }
}

# Получение значения через многострочный доступ
result = (
    customer_data
    ["data"]
    ["num"]
)

result

"""# 3. Написание читаемых и информативных функций

Как мы раньше писали функции, будучи студентами:
"""

def foo(a, b, c, d, e):
  pass

"""PR, содержащие такой код, скорее всего, будут отклонены:

1. **Ненасыщенные имена**  
   - **Проблема**: Имя функции не отражает её логику (например, `func()` вместо `calculate_profit()`).  
   - **Решение**: Используйте описательные имена, которые сразу дают понять цель функции.  

2. **Неинформативные переменные**  
   - **Проблема**: Параметры типа `a`, `b`, `c` не указывают на их назначение.  
   - **Решение**: Называйте переменные так, чтобы их роль была ясна (например, `revenue`, `expenses`).  

3. **Отсутствие типизации**  
   - **Проблема**: Нет подсказок типов для параметров и возвращаемых значений.  
   - **Решение**: Добавьте аннотации типов для параметров и возвращаемого значения.  

4. **Нет документации**  
   - **Проблема**: Строка документации отсутствует, что затрудняет понимание функции.  
   - **Решение**: Опишите функцию в docstring, включая параметры, возвращаемое значение и пример использования.  

Пример плохого кода:
"""

def func(a, b):
    return a - b

"""Пример хорошего кода:"""

def calculate_net_profit(revenue: float, expenses: float) -> float:
    """
    Вычисляет чистую прибыль по формуле: revenue - expenses.

    Args:
        revenue (float): Общая выручка.
        expenses (float): Общие расходы.

    Returns:
        float: Чистая прибыль.
    """
    return revenue - expenses

"""Вот как мы пишем функции в коде Python, готовом к производственной среде.
### **Почему так делают?**  
1. **Читаемость**  
   - Описательные имена и docstrings помогают другим разработчикам быстро понять логику.  
2. **Безопасность**  
   - Типизация предотвращает ошибки (например, передача строки вместо числа).  
3. **Поддержка**  
   - Документация упрощает модификацию кода в будущем.  

**Примечание**: Для сложных функций используйте разделение на логические блоки и тесты.

# 4. Снижение уровня отступов

Отступы в Python являются неотъемлемой частью синтаксиса, так как они используются для обозначения блоков кода. Однако чрезмерная вложенность может ухудшить читаемость и сопровождение кода. Снижение уровня отступов помогает сделать код более понятным и поддерживаемым.

### **Почему важно снижать уровень отступов?**
1. **Улучшение читаемости**: Глубокие вложенные блоки затрудняют понимание логики программы.
2. **Простота сопровождения**: Меньше вложений упрощает внесение изменений в код.
3. **Снижение риска ошибок**: Меньшая вложенность уменьшает вероятность путаницы с уровнями отступов.


### **Методы снижения уровня отступов**

1. **Использование функций**
   - Вынос логики во вспомогательные функции уменьшает вложенность.
"""

def process_data(data):
       if data:
           return [x * 2 for x in data if x > 0]
       return []

   result = process_data([1, -2, 3])

"""2. **Ранний выход из функции (early return)**
   - Избегайте вложенных `if`-блоков, возвращая результат как можно раньше.
"""

def check_value(value):
    if value < 0:
        return "Negative"
    if value == 0:
        return "Zero"
    return "Positive"

"""3. **Использование циклов вместо вложенных условий**
   - Перепишите вложенные конструкции с помощью циклов или итераторов.
"""

# Вместо этого:
for user in users:
    if user["is_active"]:
        if user["age"] > 18:
            print(f"Active adult: {user['name']}")

# Используйте:
for user in (u for u in users if u["is_active"] and u["age"] > 18):
    print(f"Active adult: {user['name']}")

"""4. **Разделение логики на несколько функций или классов**
   - Сложные конструкции можно разбить на несколько модулей или методов.
"""

class DataProcessor:
       def __init__(self, data):
           self.data = data

       def filter_data(self):
           return [x for x in self.data if x > 0]

       def process(self):
           filtered_data = self.filter_data()
           return [x * 2 for x in filtered_data]

processor = DataProcessor([1, -2, 3])
result = processor.process()

"""### **Пример до и после снижения уровня отступов**

**До:**
"""

def analyze_data(data):
    if data:
        for item in data:
            if item > 0:
                print(f"Positive item: {item}")

"""**После:**

"""

def analyze_data(data):
    if not data:
        return
    for item in (x for x in data if x > 0):
        print(f"Positive item: {item}")

"""### **Рекомендации**
- Следуйте PEP 8: используйте 4 пробела для каждого уровня отступа.
- Избегайте глубокой вложенности (>3 уровней).
- Используйте линтеры и автоформатеры, такие как `black` или `autopep8`, чтобы автоматически исправлять стиль кода.

Снижение уровня отступов делает код более профессиональным, читаемым и простым в сопровождении.
"""